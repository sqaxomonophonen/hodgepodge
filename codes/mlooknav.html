<!doctype HTML>
<html>
<head>

<title>mlooknav</title>

<style>

body {
	background: black;
	margin: 0px;
}

#canvas {
	position: absolute;
	width: 100%;
	height: 100%;
}

</style>


<script>

const deg2rad = (deg) => deg / 180 * Math.PI;
const m4ati = (col, row) => row + col*4;

const m4zero = () => [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];

const m4identity = () => {
	let m = m4zero();
	for (let x = 0; x < 4; x++) m[m4ati(x,x)] = 1;
	return m;
};

const m4mul = (a, b) => {
	let m = m4zero();
	for (let col = 0; col < 4; col++) {
		for (let row = 0; row < 4; row++) {
			m[m4ati(col,row)] = v4dot(m4row(a,row), m4col(b,col));
		}
	}
	return m;
};

const m4rotation = (axis, phi) => {
	let m = m4identity();
	let c = Math.cos(deg2rad(phi));
	let s = Math.sin(deg2rad(phi));
	let c1 = 1-c;
	for (let col = 0; col < 3; col++) {
		for (let row = 0; row < 3; row++) {
			let v = axis[col] * axis[row] * c1;
			if (col == row) {
				v += c;
			} else {
				let i = 3 - row - col;
				let sgn1 = ((col + row)&1) ? 1 : -1;
				let sgn2 = row>col ? 1 : -1;
				v += sgn1 * sgn2 * axis[i] * s;
			}
			m[m4ati(col,row)] = v;
		}
	}
	return m;
};

const m4translation = (v4) => {
	let m = m4identity();
	for (let row = 0; row < 3; row++) {
		m[m4ati(3,row)] = v4[row];
	}
	return m;
};

const m4frustum = (left, right, down, up, znear, zfar) => {
	let m = m4zero();

	m[m4ati(0,0)] = 2 * znear / (right - left);
	m[m4ati(1,1)] = 2 * znear / (up - down);

	m[m4ati(2,0)] = (right+left)/(right-left); // A
	m[m4ati(2,1)] = (up+down)/(up-down); // B
	m[m4ati(2,2)] = -((zfar+znear)/(zfar-znear)); // C
	m[m4ati(2,3)] = -1;

	m[m4ati(3,2)] = -(2 * zfar * znear / (zfar - znear)); // D

	return m;
};

const m4perspective = (fovy, aspect, znear, zfar) => {
	let dy = znear * Math.tan(deg2rad(fovy)/2);
	let dx = dy * aspect;
	return m4frustum(-dx, dx, -dy, dy, znear, zfar);
};

const m4row = (m4, row) => {
	let v4 = [];
	for (let col = 0; col < 4; col++) {
		v4.push(m4[m4ati(col, row)]);
	}
	return v4;
};

const m4col = (m4, col) => {
	let v4 = [];
	for (let row = 0; row < 4; row++) {
		v4.push(m4[m4ati(col, row)]);
	}
	return v4;
};

const m4sub3 = (m, delcol, delrow, col, row) => {
	if (col >= delcol) col++;
	if (row >= delrow) row++;
	return m[m4ati(col, row)];
};

const m4minors = (m) => {
	let r = m4identity();
	for (let row = 0; row < 4; row++) {
		for (let col = 0; col < 4; col++) {
			let det = 0;
			for (let x = 0; x < 3; x++) {
				let s = 1;
				for (let i = 0; i < 3; i++) {
					s *= m4sub3(m, col, row, (i+x+6)%3, i);
				}
				det += s;

				let t = 1;
				for (let i = 0; i < 3; i++) {
					t *= m4sub3(m, col, row,  (-i+x+6)%3, i);
				}
				det -= t;
			}
			r[m4ati(col,row)] = det;
		}
	}
	return r;
};

const m4cofactors = (m) => {
	let m2 = m4minors(m);
	for (let row = 0; row < 4; row++) {
		for (let col = 0; col < 4; col++) {
			if ((col+row)&1 > 0) {
				m2[m4ati(col,row)] *= -1;
			}
		}
	}
	return m2;
};

const m4transpose = (m) => {
	let r = m4zero();
	for (let row = 0; row < 4; row++) {
		for (let col = 0; col < 4; col++) {
			r[m4ati(row,col)] = m[m4ati(col,row)];
		}
	}
	return r;
};


const m4adjugate = (m) => m4transpose(m4cofactors(m));
const m4determinant = (m) => {
	let det = 0;
	for (let x = 0; x < 4; x++) {
		let s = 1;
		for (let i = 0; i < 4; i++) {
			//s *= mat44_at(a, (i+x)&3, i);

			s *= m[m4ati((i+x)%4, i)];
		}
		det += s;

		let t = 1;
		for (let i = 0; i < 4; i++) {
			t *= m[m4ati((-i+x+4)%4, i)];
		}
		det -= t;
	}
	return det;
};

const m4inverse = (m) => {
	let r = m4adjugate(m);
	let det = m4determinant(m);
	let scalar = 1/det;
	return r.map(x=>x*scalar);
};

const vndot = (n,a,b) => {
	let v = 0;
	for (let i = 0; i < n; i++) {
		v += a[i]*b[i];
	}
	return v;
};

const v4dot = (a,b) => vndot(4,a,b);
const v3dot = (a,b) => vndot(3,a,b);
const v2dot = (a,b) => vndot(2,a,b);
const vnlen = (n,v) => Math.sqrt(vndot(n,v,v));
const v3len = (v3) => vnlen(3,v3);
const v2len = (v2) => vnlen(2,v2);

const v3apply = (v3, m4) => {
	let v4 = [v3[0],v3[1],v3[2],1];
	let r4 = [];
	for (let i = 0; i < 4; i++) {
		let row = m4row(m4, i);
		r4.push(v4dot(v4,row));
	}
	return [r4[0]/r4[3], r4[1]/r4[3], r4[2]/r4[3]];
};

const v3rotate = (v3, axis, phi) => v3apply(v3, m4rotation(axis, phi));

const v3cross = (a,b) => {
	let r = [];
	for (let i = 0; i < 3; i++) {
		let i1 = (i+1)%3;
		let i2 = (i+2)%3;
		r.push(a[i1]*b[i2] - a[i2]*b[i1]);
	}
	return r;
};

const v3normalize = (v3) => {
	let s = 1/v3len(v3);
	let r = [];
	for (let i = 0; i < 3; i++) {
		r.push(v3[i] * s);
	}
	return r;
};

const vnadd = (n,a,b) => {
	let s = [];
	for (let i = 0; i < n; i++) {
		s.push(a[i] + b[i]);
	}
	return s;
};

const vnsub = (n,a,b) => {
	let s = [];
	for (let i = 0; i < n; i++) {
		s.push(a[i] - b[i]);
	}
	return s;
};

const v3add = (a,b) => vnadd(3,a,b);
const v2add = (a,b) => vnadd(2,a,b);
const v2sub = (a,b) => vnsub(2,a,b);
const vscale = (v, scalar) => v.map(function (v) { return v * scalar; });


window.onload = () => {
	const panic = (m) => { throw new Error(m); }

	const request_animation_frame = (
		window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		((cb) => { window.setTimeout(cb, 1000/60); })
	);

	let canvas = document.getElementById("canvas");
	let gl = canvas.getContext('webgl');
	if (!gl) panic("no webgl context");


	const mk_shader = (vsrc, fsrc, attributes) => {
		let create_shader = function (type, src) {
			let shader = gl.createShader(type);
			gl.shaderSource(shader, src);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				panic(gl.getShaderInfoLog(shader));
			}
			return shader;
		};

		let vs = create_shader(gl.VERTEX_SHADER, vsrc);
		let fs = create_shader(gl.FRAGMENT_SHADER, fsrc);

		let prg = gl.createProgram();
		gl.attachShader(prg, vs);
		gl.attachShader(prg, fs);
		gl.linkProgram(prg);

		if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) panic("link error");

		let attribs = (function () {
			let total = 0;
			let args = [];
			for (let i in attributes) {
				let name = attributes[i][0];
				let length = attributes[i][1];
				args.push({
					"loc": gl.getAttribLocation(prg, name),
					"length": length,
					"offset": total * 4
				});
				total += length;
			}
			return {
				"stride": total * 4,
				"args": args
			};
		})();

		let ucache = {};
		let uniform = function (name) {
			if (!ucache[name]) {
				ucache[name] = gl.getUniformLocation(prg, name);
			}
			return ucache[name];
		};

		return {
			setup_vertex_attrib_pointers: () => {
				for (let i in attribs.args) {
					let args = attribs.args[i];
					gl.vertexAttribPointer(
						args.loc,
						args.length,
						gl.FLOAT,
						false,
						attribs.stride,
						args.offset
					);
				};
			},
			set_uniform_matrix: (name, value) => gl.uniformMatrix4fv(uniform(name), false, new Float32Array(value)),
			set_uniform_float: (name, value) => gl.uniform1f(uniform(name), value),
			set_uniform_v2: (name, value) => gl.uniform2f(uniform(name), value[0], value[1]),
			set_uniform_v3: (name, value) => gl.uniform3f(uniform(name), value[0], value[1], value[2]),
			set_uniform_v4: (name, value) => gl.uniform4f(uniform(name), value[0], value[1], value[2], value[3]),
			set_uniform_int: (name, value) => gl.uniform1i(uniform(name), value),
			enable: () => {
				gl.useProgram(prg);
				for (let i in attribs.args) {
					gl.enableVertexAttribArray(attribs.args[i].loc);
				}
			},
			disable: () => {
				for (let i in attribs.args) {
					gl.disableVertexAttribArray(attribs.args[i].loc);
				}
			},
		};
	};

	const mk_stage = (width, height) => {
		const mk_src = (width, height) => {
			let canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;

			const ctx = canvas.getContext('2d');

			ctx.globalCompositeOperation = "lighter";

			ctx.fillStyle = '#000000';
			ctx.fillRect(0, 0, width, height);

			ctx.fillStyle = '#ffffff';
			ctx.font = '65px serif';

			const N = 4000;
			const S = "0123456789ABCDEF";
			for (let i = 0; i < N; i++) {
				let x = Math.random()*width;
				let y = Math.random()*height;
				let r = Math.random()*2.0*Math.PI;
				for (let dy = -1; dy <= 1; dy++) {
					for (let dx = -1; dx <= 1; dx++) {
						ctx.save();
						ctx.translate(x+dx*width, y+dy*height);
						ctx.rotate(r);
						ctx.fillText(S[i%S.length],0,0);
						ctx.restore();
					}
				}
			}

			return canvas;
		};

		let src = mk_src(width, height);

		let texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
		gl.generateMipmap(gl.TEXTURE_2D);

		let shader = mk_shader(`
			attribute vec3 a_position;
			attribute vec2 a_uv;

			varying vec2 v_uv;

			uniform mat4 u_tx;

			void main(void)
			{
				v_uv = a_uv;
				gl_Position = u_tx * vec4(a_position,1);
			}
		`, `
			precision mediump float;

			varying vec2 v_uv;

			uniform vec4 u_color_bg;
			uniform vec4 u_color_fg;
			uniform sampler2D u_texture;

			void main(void)
			{
				float s = texture2D(u_texture, v_uv).r;
				gl_FragColor = mix(u_color_bg, u_color_fg, s);
			}
		`, [
			["a_position",3],
			["a_uv",2],
		]);

		let buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		let R = 16;
		let W = width * R;
		let H = height;
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			// x,y,z,   u,v,

			0,0,0,   0,0,
			W,0,0,   R,0,
			W,H,0,   R,1,

			0,0,0,   0,0,
			W,H,0,   R,1,
			0,H,0,   0,1,

		]), gl.STATIC_DRAW);

		return {
			src: src,
			texture: texture,
			shader: shader,
			buffer: buffer,
			n_vertices: 6,
		};
	};

	let stage = mk_stage(1<<13, 1<<11);

	let cursor = (() => {

		let mk_vs = (inside, indices) => {
			let vs = [];
			for (const index of indices) {
				vs.push(index);
				vs.push(inside ? 1 : 0);
			}
			return vs;
		};

		// 0----------1
		// |\        /|
		// | 2------3 |
		// | |      | |
		// | |      | |
		// | 4------5 |
		// |/        \|
		// 6----------7

		let vertices = [
			...(mk_vs(false, [
				0,1,3,  0,3,2,
				1,7,5,  1,5,3,
				4,5,7,  4,7,6,
				0,2,4,  0,4,6,
			])),
			...(mk_vs(true, [
				2,3,5,  2,5,4,
			])),
		];

		let buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

		let shader = mk_shader(`
			attribute float a_index;
			attribute float a_inside;

			uniform mat4 u_tx;
			uniform vec2 u_outer_p0;
			uniform vec2 u_outer_p1;
			uniform vec2 u_inner_p0;
			uniform vec2 u_inner_p1;

			varying float v_inside;

			void main(void)
			{
				v_inside = a_inside;
				vec2 pos = vec2(0,0);
				if (a_index == 0.0) {
					pos = vec2( u_outer_p0.x, u_outer_p0.y );
				} else if (a_index == 1.0) {
					pos = vec2( u_outer_p1.x, u_outer_p0.y );
				} else if (a_index == 2.0) {
					pos = vec2( u_inner_p0.x, u_inner_p0.y );
				} else if (a_index == 3.0) {
					pos = vec2( u_inner_p1.x, u_inner_p0.y );
				} else if (a_index == 4.0) {
					pos = vec2( u_inner_p0.x, u_inner_p1.y );
				} else if (a_index == 5.0) {
					pos = vec2( u_inner_p1.x, u_inner_p1.y );
				} else if (a_index == 6.0) {
					pos = vec2( u_outer_p0.x, u_outer_p1.y );
				} else if (a_index == 7.0) {
					pos = vec2( u_outer_p1.x, u_outer_p1.y );
				}
				gl_Position = u_tx * vec4(pos,0,1);
			}
		`, `
			precision mediump float;

			uniform vec4 u_color_outside;
			uniform vec4 u_color_inside;

			varying float v_inside;

			void main(void)
			{
				gl_FragColor = mix(u_color_outside, u_color_inside, v_inside);
			}
		`, [
			["a_index",1],
			["a_inside",1],
		]);

		return {
			shader: shader,
			buffer: buffer,
			n_vertices: vertices.length / 2,
		};
	})();

	let rot0 = 0.0;
	let rot1 = 0.0;
	let distance = 1500;

	let is_cursoring = false;
	let cursoring_fade = 0;

	let set_cursoring = (p) => {
		is_cursoring = p;

		if (p) {
			document.body.requestPointerLock();
			cursoring_fade = 0;
		} else {
			document.exitPointerLock();
			rot0 = rot1 = 0;
		}
	};

	window.addEventListener("contextmenu", (e) => { e.preventDefault(); });

	window.addEventListener("mousedown", (e) => {
		let b = e.button;
		if (!is_cursoring && b === 2) {
			set_cursoring(true);
		} else if (is_cursoring && b === 0) {
			set_cursoring(false);
		}
		e.preventDefault();
	});

	window.addEventListener("mousemove", (e) => {
		if (is_cursoring) {
			let dx = e.movementX;
			let dy = e.movementY;
			const sens = 0.03;
			rot0 += dx * sens;
			rot1 += dy * sens;
		}
	});

	const begin_loop = () => {
		gl.enable(gl.BLEND);
		gl.blendFuncSeparate(
			gl.ONE, gl.ONE_MINUS_SRC_ALPHA,
			gl.ONE, gl.ZERO,
		);

		gl.disable(gl.DEPTH_TEST);
		//gl.depthMask(true);
		gl.disable(gl.CULL_FACE);
		gl.clearColor(0, 0.0, 0, 1.0);

		(function loop() {
			let width = canvas.offsetWidth;
			let height = canvas.offsetHeight;
			canvas.width = width;
			canvas.height = height;
			gl.viewport(0, 0, width, height);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			let projection = m4perspective(65, width/height, 5, 40000);
			let view = m4identity();
			view = m4mul(view, m4rotation([1,0,0], rot1));
			view = m4mul(view, m4rotation([0,1,0], rot0));
			view = m4mul(view, m4translation([0,0,-distance]));
			let tx = m4mul(projection, view);

			stage.shader.enable();
			gl.bindBuffer(gl.ARRAY_BUFFER, stage.buffer);
			stage.shader.setup_vertex_attrib_pointers();
			stage.shader.set_uniform_matrix("u_tx", tx);
			stage.shader.set_uniform_v4("u_color_bg", [0.0,  0.0,  0.2,  1.0]);
			stage.shader.set_uniform_v4("u_color_fg", [1.0,  1.0,  1.0,  1.0]);

			gl.drawArrays(gl.TRIANGLES, 0, stage.n_vertices);

			if (is_cursoring) {

				let iview = m4inverse(view);
				console.log(m4col(iview,3));


				cursor.shader.enable();
				gl.bindBuffer(gl.ARRAY_BUFFER, cursor.buffer);
				cursor.shader.setup_vertex_attrib_pointers();
				cursor.shader.set_uniform_matrix("u_tx", tx);
				cursor.shader.set_uniform_v4("u_color_outside", vscale([0.0,  0.0,  0.0,  0.8], cursoring_fade));
				cursor.shader.set_uniform_v4("u_color_inside",  vscale([0.6,  0.5,  0.2,  0.0], cursoring_fade));
				let xfar = 100000;
				let yfar = 10000;
				cursor.shader.set_uniform_v2("u_outer_p0", [-xfar,-yfar]);
				cursor.shader.set_uniform_v2("u_outer_p1", [xfar,yfar]);
				cursor.shader.set_uniform_v2("u_inner_p0", [-300,-100]);
				cursor.shader.set_uniform_v2("u_inner_p1", [300,100]);
				gl.drawArrays(gl.TRIANGLES, 0, cursor.n_vertices);

				cursoring_fade = Math.min(1.0, cursoring_fade + 0.15);
			}

			request_animation_frame(loop);
		})();
	};

	begin_loop();
};
</script>

</head>
<body>
<canvas id="canvas"></canvas>
</body>
</html>
