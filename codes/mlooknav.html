<!doctype HTML>
<html>
<head>

<title>mlooknav</title>

<style>

body {
	background: black;
	margin: 0px;
}

#canvas {
	position: absolute;
	width: 100%;
	height: 100%;
}

</style>


<script>

const deg2rad = (deg) => deg / 180 * Math.PI;
const m4ati = (col, row) => row + col*4;

const m4identity = () => {
	let m = [];
	for (let col = 0; col < 4; col++) {
		for (let row = 0; row < 4; row++) {
			m.push(row == col ? 1 : 0);
		}
	}
	return m;
};

const m4zero = () => {
	var m = [];
	for (var col = 0; col < 4; col++) {
		for (var row = 0; row < 4; row++) {
			m.push(0);
		}
	}
	return m;
};

const m4mul = (a, b) => {
	let m = [];
	for (let col = 0; col < 4; col++) {
		for (let row = 0; row < 4; row++) {
			m.push(v4dot(m4row(a,row), m4col(b,col)));
		}
	}
	return m;
};

const m4rotation = (axis, phi) => {
	let m = m4identity();
	let c = Math.cos(deg2rad(phi));
	let s = Math.sin(deg2rad(phi));
	let c1 = 1-c;
	for (let col = 0; col < 3; col++) {
		for (let row = 0; row < 3; row++) {
			let v = axis[col] * axis[row] * c1;
			if (col == row) {
				v += c;
			} else {
				let i = 3 - row - col;
				let sgn1 = ((col + row)&1) ? 1 : -1;
				let sgn2 = row>col ? 1 : -1;
				v += sgn1 * sgn2 * axis[i] * s;
			}
			m[m4ati(col,row)] = v;
		}
	}
	return m;
};

const m4translation = (v4) => {
	let m = m4identity();
	for (let row = 0; row < 3; row++) {
		m[m4ati(3,row)] = v4[row];
	}
	return m;
};

const m4frustum = (left, right, down, up, znear, zfar) => {
	let m = m4zero();

	m[m4ati(0,0)] = 2 * znear / (right - left);
	m[m4ati(1,1)] = 2 * znear / (up - down);

	m[m4ati(2,0)] = (right+left)/(right-left); // A
	m[m4ati(2,1)] = (up+down)/(up-down); // B
	m[m4ati(2,2)] = -((zfar+znear)/(zfar-znear)); // C
	m[m4ati(2,3)] = -1;

	m[m4ati(3,2)] = -(2 * zfar * znear / (zfar - znear)); // D

	return m;
};

const m4perspective = (fovy, aspect, znear, zfar) => {
	let dy = znear * Math.tan(deg2rad(fovy)/2);
	let dx = dy * aspect;
	return m4frustum(-dx, dx, -dy, dy, znear, zfar);
};

const m4row = (m4, row) => {
	let v4 = [];
	for (let col = 0; col < 4; col++) {
		v4.push(m4[m4ati(col, row)]);
	}
	return v4;
};

const m4col = (m4, col) => {
	let v4 = [];
	for (let row = 0; row < 4; row++) {
		v4.push(m4[m4ati(col, row)]);
	}
	return v4;
};

const vndot = (n,a,b) => {
	let v = 0;
	for (let i = 0; i < n; i++) {
		v += a[i]*b[i];
	}
	return v;
};

const v4dot = (a,b) => vndot(4,a,b);
const v3dot = (a,b) => vndot(3,a,b);
const v2dot = (a,b) => vndot(2,a,b);
const vnlen = (n,v) => Math.sqrt(vndot(n,v,v));
const v3len = (v3) => vnlen(3,v3);
const v2len = (v2) => vnlen(2,v2);

const v3apply = (v3, m4) => {
	let v4 = [v3[0],v3[1],v3[2],1];
	let r4 = [];
	for (let i = 0; i < 4; i++) {
		let row = m4row(m4, i);
		r4.push(v4dot(v4,row));
	}
	return [r4[0]/r4[3], r4[1]/r4[3], r4[2]/r4[3]];
};

const v3rotate = (v3, axis, phi) => v3apply(v3, m4rotation(axis, phi));

const v3cross = (a,b) => {
	let r = [];
	for (let i = 0; i < 3; i++) {
		let i1 = (i+1)%3;
		let i2 = (i+2)%3;
		r.push(a[i1]*b[i2] - a[i2]*b[i1]);
	}
	return r;
};

const v3normalize = (v3) => {
	let s = 1/v3len(v3);
	let r = [];
	for (let i = 0; i < 3; i++) {
		r.push(v3[i] * s);
	}
	return r;
};

const vnadd = (n,a,b) => {
	let s = [];
	for (let i = 0; i < n; i++) {
		s.push(a[i] + b[i]);
	}
	return s;
};

const vnsub = (n,a,b) => {
	let s = [];
	for (let i = 0; i < n; i++) {
		s.push(a[i] - b[i]);
	}
	return s;
};

const v3add = (a,b) => vnadd(3,a,b);
const v2add = (a,b) => vnadd(2,a,b);
const v2sub = (a,b) => vnsub(2,a,b);
const vscale = (v, scalar) => v.map(function (v) { return v * scalar; });


window.onload = () => {
	const panic = (m) => { throw new Error(m); }

	const request_animation_frame = (
		window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		((cb) => { window.setTimeout(cb, 1000/60); })
	);

	let canvas = document.getElementById("canvas");
	let gl = canvas.getContext('webgl');
	if (!gl) panic("no webgl context");


	const mk_shader = (vsrc, fsrc, attributes) => {
		let create_shader = function (type, src) {
			let shader = gl.createShader(type);
			gl.shaderSource(shader, src);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				panic(gl.getShaderInfoLog(shader));
			}
			return shader;
		};

		let vs = create_shader(gl.VERTEX_SHADER, vsrc);
		let fs = create_shader(gl.FRAGMENT_SHADER, fsrc);

		let prg = gl.createProgram();
		gl.attachShader(prg, vs);
		gl.attachShader(prg, fs);
		gl.linkProgram(prg);

		if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) panic("link error");

		let attribs = (function () {
			let total = 0;
			let args = [];
			for (let i in attributes) {
				let name = attributes[i][0];
				let length = attributes[i][1];
				args.push({
					"loc": gl.getAttribLocation(prg, name),
					"length": length,
					"offset": total * 4
				});
				total += length;
			}
			return {
				"stride": total * 4,
				"args": args
			};
		})();

		let ucache = {};
		let uniform = function (name) {
			if (!ucache[name]) {
				ucache[name] = gl.getUniformLocation(prg, name);
			}
			return ucache[name];
		};

		return {
			setup_vertex_attrib_pointers: () => {
				for (let i in attribs.args) {
					let args = attribs.args[i];
					gl.vertexAttribPointer(
						args.loc,
						args.length,
						gl.FLOAT,
						false,
						attribs.stride,
						args.offset
					);
				};
			},
			set_uniform_matrix: (name, value) => gl.uniformMatrix4fv(uniform(name), false, new Float32Array(value)),
			set_uniform_float: (name, value) => gl.uniform1f(uniform(name), value),
			set_uniform_v3: (name, value) => gl.uniform3f(uniform(name), value[0], value[1], value[2]),
			set_uniform_int: (name, value) => gl.uniform1i(uniform(name), value),
			enable: () => {
				gl.useProgram(prg);
				for (let i in attribs.args) {
					gl.enableVertexAttribArray(attribs.args[i].loc);
				}
			},
			disable: () => {
				for (let i in attribs.args) {
					gl.disableVertexAttribArray(attribs.args[i].loc);
				}
			},
		};
	};

	const mk_stage = (width, height) => {
		const mk_src = (width, height) => {
			let canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;

			const ctx = canvas.getContext('2d');

			ctx.globalCompositeOperation = "lighter";

			ctx.fillStyle = '#000000';
			ctx.fillRect(0, 0, width, height);

			ctx.fillStyle = '#ffffff';
			ctx.font = '65px serif';

			const N = 4000;
			const S = "0123456789ABCDEF";
			for (let i = 0; i < N; i++) {
				let x = Math.random()*width;
				let y = Math.random()*height;
				let r = Math.random()*2.0*Math.PI;
				for (let dy = -1; dy <= 1; dy++) {
					for (let dx = -1; dx <= 1; dx++) {
						ctx.save();
						ctx.translate(x+dx*width, y+dy*height);
						ctx.rotate(r);
						ctx.fillText(S[i%S.length],0,0);
						ctx.restore();
					}
				}
			}

			return canvas;
		};

		let src = mk_src(width, height);

		let texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
		gl.generateMipmap(gl.TEXTURE_2D);

		let shader = mk_shader(`

attribute vec3 a_position;
attribute vec2 a_uv;

varying vec2 v_uv;

uniform mat4 u_projection;
uniform mat4 u_view;

void main(void)
{
	v_uv = a_uv;
	gl_Position = u_projection * u_view * vec4(a_position,1);
}

		`, `

precision mediump float;

varying vec2 v_uv;

uniform sampler2D u_texture;

void main(void)
{
	float s = texture2D(u_texture, v_uv).r;
	//gl_FragColor = vec4(0.0, 0.0, 0.0, s);
	gl_FragColor = mix(
		vec4(0.0, 0.0, 0.2, 1.0),
		vec4(1.0, 1.0, 1.0, 1.0),
		s);
}

		`, [
			["a_position",3],
			["a_uv",2],
		]);


		let buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		let R = 16;
		let W = width * R;
		let H = height;
		let W0 = -W/2;
		let W1 = W/2;
		let H0 = -H/2;
		let H1 = H/2;
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			// x,y,z,   u,v,

			W0,H0,0,   0,0,
			W1,H0,0,   R,0,
			W1,H1,0,   R,1,

			W0,H0,0,   0,0,
			W1,H1,0,   R,1,
			W0,H1,0,   0,1,

		]), gl.STATIC_DRAW);

		return {
			src: src,
			texture: texture,
			shader: shader,
			buffer: buffer,
		};
	};

	let stage = mk_stage(1<<13, 1<<11);

	let rot0 = 0.0;
	let distance = 1500;

	const begin_loop = () => {
		gl.enable(gl.BLEND);
		gl.blendFuncSeparate(
			gl.ONE, gl.ONE_MINUS_SRC_ALPHA,
			gl.ONE, gl.ZERO,
		);
		gl.enable(gl.DEPTH_TEST);
		gl.depthMask(true);
		gl.disable(gl.CULL_FACE);
		gl.clearColor(0, 0.0, 0, 1.0);

		(function loop() {
			let width = canvas.offsetWidth;
			let height = canvas.offsetHeight;
			canvas.width = width;
			canvas.height = height;
			gl.viewport(0, 0, width, height);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			let projection = m4perspective(65, width/height, 5, 40000);
			let view = m4identity();
			view = m4mul(view, m4translation([0,0,-distance]));
			view = m4mul(view, m4rotation([0,1,0], rot0));

			stage.shader.enable();
			gl.bindBuffer(gl.ARRAY_BUFFER, stage.buffer);
			stage.shader.setup_vertex_attrib_pointers();
			stage.shader.set_uniform_matrix("u_projection", projection);
			stage.shader.set_uniform_matrix("u_view", view);
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			rot0 += 0.1;

			request_animation_frame(loop);
		})();
	};

	begin_loop();
};
</script>

</head>
<body>
<canvas id="canvas"></canvas>
</body>
</html>
